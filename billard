import pygame
import math
import sys

from Cue import Cue
from Pocket import Pocket
from funky import arrange_balls_at_positions, reset_game, check_pocket_collision, msgbox, gameStatus

pygame.init()

# Liste zum Speichern der eingespielten Kugeln
sunk_balls = []

# Bildschirmabmessungen
WINDOW_WIDTH, WINDOW_HEIGHT = 800, 600
WINDOW_SIZE = (WINDOW_WIDTH, WINDOW_HEIGHT)

# Farben
WHITE = (250, 250, 250)
DARK_GREEN = (0, 80, 0)  # Dunkleres Grün für das Spielfeld
RED = (255, 0, 0)
GREEN = (0, 200, 0)  # Hellere grüne Farbe für die Kugel
BLUE = (0, 0, 255)
BROWN = (139, 69, 19)
LIGHT_BROWN = (210, 180, 140)
YELLOW = (255, 255, 0)
VIOLET = (128, 0, 128)
BLACK = (0, 0, 0)

# Initialisierung des Fensters
window = pygame.display.set_mode(WINDOW_SIZE)
pygame.display.set_caption("Billard")


def main():
    clock = pygame.time.Clock()

    # Kugelfarben definieren
    ball_colors = [
        WHITE, BLACK, RED,
        GREEN, BLUE, BROWN, LIGHT_BROWN,
        YELLOW, VIOLET, RED,
        GREEN, BLUE, BROWN,
        LIGHT_BROWN, YELLOW, VIOLET,
        DARK_GREEN, YELLOW
    ]

    # Positionen der Kugeln, habe ich händisch eingegeben
    positions = [
        (WINDOW_WIDTH // 4, WINDOW_HEIGHT // 2),
        (WINDOW_WIDTH * 3 // 4 - 50, WINDOW_HEIGHT // 2),

        (WINDOW_WIDTH * 3 // 4 - 10, WINDOW_HEIGHT // 2 - 20),
        (WINDOW_WIDTH * 3 // 4 - 10, WINDOW_HEIGHT // 2 + 25),
        (WINDOW_WIDTH * 3 // 4 + 30, WINDOW_HEIGHT // 2),
        (WINDOW_WIDTH * 3 // 4 + 30, WINDOW_HEIGHT // 2 + 45),
        (WINDOW_WIDTH * 3 // 4 + 30, WINDOW_HEIGHT // 2 - 45),
        (WINDOW_WIDTH * 3 // 4 + 70, WINDOW_HEIGHT // 2 + 70),
        (WINDOW_WIDTH * 3 // 4 + 70, WINDOW_HEIGHT // 2 + 25),
        (WINDOW_WIDTH * 3 // 4 + 70, WINDOW_HEIGHT // 2 - 20),
        (WINDOW_WIDTH * 3 // 4 + 70, WINDOW_HEIGHT // 2 - 65),
        (WINDOW_WIDTH * 3 // 4 + 110, WINDOW_HEIGHT // 2 + 90),
        (WINDOW_WIDTH * 3 // 4 + 110, WINDOW_HEIGHT // 2 + 45),
        (WINDOW_WIDTH * 3 // 4 + 110, WINDOW_HEIGHT // 2),
        (WINDOW_WIDTH * 3 // 4 + 110, WINDOW_HEIGHT // 2 - 45),
        (WINDOW_WIDTH * 3 // 4 + 110, WINDOW_HEIGHT // 2 - 90)
    ]

    # Erstellen der Kugeln und Speichern in einer Liste
    balls = arrange_balls_at_positions(ball_colors, positions)

    # Erstellen des Queues
    cue = Cue(balls[0].x, balls[0].y)

    # Taschen (Fangkörbe) erstellen
    # brauche pocket1 und pocket2 für den RESET Button
    pocket1 = Pocket(30, 30, BLACK, 30)
    pocket2 = Pocket(WINDOW_WIDTH - 30, 30, BLACK, 30)
    pockets = [
        pocket1, pocket2,
        Pocket(30, WINDOW_HEIGHT - 30, BLACK, 30),
        Pocket(WINDOW_WIDTH - 30, WINDOW_HEIGHT - 30, BLACK, 30),
        Pocket(WINDOW_WIDTH // 2, 30, BLACK, 30),
        Pocket(WINDOW_WIDTH // 2, WINDOW_HEIGHT - 30, BLACK, 30)
    ]

    # Reset-Button erstellen
    reset_button_x = (pocket1.x + pocket2.x) // 2 - 260
    reset_button_y = 10
    reset_button_width = 100
    reset_button_height = 30

    cue.visible = True

    # Dämpfungsfaktor für das Stoppen der Kugeln
    damping = 0.95

    playing = True
    while playing:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                playing = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                if cue.visible:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    cue_length = math.sqrt((mouse_x - balls[0].x) ** 2 + (mouse_y - balls[0].y) ** 2)
                    cue_vel = cue_length * 0.2
                    balls[0].vel_x = cue_vel * math.cos(cue.angle)
                    balls[0].vel_y = cue_vel * math.sin(cue.angle)
                    cue.visible = False

                # Überprüfen, ob der Reset-Button angeklickt wurde
                mouse_pos = pygame.mouse.get_pos()
                if reset_button_x <= mouse_pos[0] <= reset_button_x + reset_button_width and \
                        reset_button_y <= mouse_pos[1] <= reset_button_y + reset_button_height:
                    # Überprüfen, ob die schwarze Kugel mit anderen Kugeln überlappt
                    overlapping = False
                    for ball in balls[1:]:
                        if balls[0].is_overlapping(ball):
                            overlapping = True
                            break

                    # Wenn die schwarze Kugel nicht mit anderen Kugeln überlappt, dann reset
                    if not overlapping:
                        reset_game(balls[0], balls[1:], ball_colors, positions, WINDOW_WIDTH, WINDOW_HEIGHT)
                        cue.visible = True
                        cue.x = balls[0].x
                        cue.y = balls[0].y

        # Bewegung der Kugeln, wenn nicht gestoßen
        if not cue.visible:
            for ball in balls[1:]:
                ball.move()
                ball.check_wall_collision(WINDOW_WIDTH, WINDOW_HEIGHT)

                # Dämpfung der Geschwindigkeit, wenn die Kugel nahezu gestoppt ist
                if abs(ball.vel_x) < 0.1 and abs(ball.vel_y) < 0.1:
                    ball.vel_x = 0
                    ball.vel_y = 0
                else:
                    ball.vel_x *= damping
                    ball.vel_y *= damping

        # Bewegung der weißen Kugel
        balls[0].move()
        balls[0].check_wall_collision(WINDOW_WIDTH, WINDOW_HEIGHT)

        # Dämpfung der Geschwindigkeit der weißen Kugel, wenn sie nahezu gestoppt ist
        if abs(balls[0].vel_x) < 0.1 and abs(balls[0].vel_y) < 0.1:
            balls[0].vel_x = 0
            balls[0].vel_y = 0
            if not cue.visible:
                cue.visible = True
                cue.x = balls[0].x
                cue.y = balls[0].y
        else:
            balls[0].vel_x *= damping
            balls[0].vel_y *= damping

        # Kollisionserkennung zwischen den Kugeln, wenn nicht gestoßen
        if not cue.visible:
            for i in range(len(balls)):
                for j in range(i + 1, len(balls)):
                    ball1 = balls[i]
                    ball2 = balls[j]
                    dx = ball1.x - ball2.x
                    dy = ball1.y - ball2.y
                    distance = math.sqrt(dx ** 2 + dy ** 2)

                    if distance <= ball1.radius + ball2.radius:
                        ball1.resolve_collision(ball2)

        # Überprüfung, ob Kugeln in Taschen gelocht wurden
        for ball in balls:
            pocket_collision = check_pocket_collision(ball, pockets)
            if ball.visible and pocket_collision:
                if ball == balls[0]:
                    print("Weiße Kugel gelocht!")
                    ball.vel_x = 0
                    ball.vel_y = 0
                    ball.x = WINDOW_WIDTH // 4
                    ball.y = WINDOW_HEIGHT // 2
                    if not cue.visible:
                        cue.visible = True
                        cue.x = ball.x
                        cue.y = ball.y
                else:
                    color_name = ""
                    for color in ball_colors:
                        if ball.color == color:
                            if color == RED:
                                color_name = "rote"
                            elif color == GREEN:
                                color_name = "grüne"
                            elif color == BLUE:
                                color_name = "blaue"
                            elif color == BROWN:
                                color_name = "braune"
                            elif color == LIGHT_BROWN:
                                color_name = "hellbraune"
                            elif color == YELLOW:
                                color_name = "gelbe"
                            elif color == VIOLET:
                                color_name = "violette"
                            elif color == BLACK:
                                color_name = "schwarze"
                            break

                    sunk_balls.append(gameStatus(ball))

                    if ball.color == BLACK:
                        if (len(sunk_balls) < 16):
                            msgbox("Leider verloren!", "Der schwarze Ball wurde versenkt.\nEs geht aber weiter.")
                            ball.visible = False
                            ball.x = WINDOW_WIDTH * 3 // 4 + 110
                            ball.y = WINDOW_HEIGHT // 2
                            ball.vel_x = 0
                            ball.vel_y = 0
                            ball.visible = True
                        else:
                            msgbox("Sie haben gewonnen!", "Herzlichen  Glückwunsch.\nSie haben gewonnen.")
                            sys.exit()
                    else:
                        print(f"{color_name.capitalize()} Kugel gelocht!")
                        msgbox("Gelocht", f"{color_name.capitalize()} Kugel gelocht!")
                        ball.visible = False

        # Hintergrund zeichnen
        window.fill(DARK_GREEN)

        # Taschen zeichnen
        for pocket in pockets:
            pocket.draw(window)

        # Kugeln zeichnen
        for ball in balls:
            ball.draw(window)

        # Queue zeichnen
        cue.update(balls)
        cue.draw(window)

        # Reset-Button zeichnen
        pygame.draw.rect(window, RED, (reset_button_x, reset_button_y, reset_button_width, reset_button_height))
        font = pygame.font.SysFont(None, 25)
        text = font.render("RESET", True, WHITE)
        window.blit(text, (reset_button_x + 25, reset_button_y + 8))

        pygame.display.update()
        clock.tick(60)

    pygame.quit()


# Der Block wird nur ausgeführt, wenn das Skript direkt ausgeführt wird.
# aber nicht ausführen, wenn es als Modul in einem anderen Skript importiert wird.
if __name__ == "__main__":
    main()
