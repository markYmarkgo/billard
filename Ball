import pygame
import math

class Ball:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.color = color
        self.radius = 20
        self.vel_x = 0
        self.vel_y = 0
        self.visible = True

    def draw(self, window):
        if self.visible:
            pygame.draw.circle(window, self.color, (int(self.x), int(self.y)), self.radius)

    def move(self):
        self.x += self.vel_x
        self.y += self.vel_y

    def check_wall_collision(self, window_width, window_height):
        if self.x - self.radius < 0 or self.x + self.radius > window_width:
            self.vel_x *= -1
        if self.y - self.radius < 0 or self.y + self.radius > window_height:
            self.vel_y *= -1

    def set_position(self, x, y):
        self.x = x
        self.y = y

    def is_overlapping(self, other_ball):
        dx = self.x - other_ball.x
        dy = self.y - other_ball.y
        distance = math.sqrt(dx ** 2 + dy ** 2)
        return distance <= self.radius + other_ball.radius

    def resolve_collision(self, other_ball):
        dx = self.x - other_ball.x
        dy = self.y - other_ball.y
        distance = math.sqrt(dx ** 2 + dy ** 2)

        # Berechnung der Überlappung
        overlap = (self.radius + other_ball.radius) - distance
        if overlap > 0:
            # Verschieben der Kugeln, um die Überlappung zu beseitigen
            angle = math.atan2(dy, dx)
            self.x += math.cos(angle) * overlap / 2
            self.y += math.sin(angle) * overlap / 2
            other_ball.x -= math.cos(angle) * overlap / 2
            other_ball.y -= math.sin(angle) * overlap / 2

            # Berechnung der neuen Geschwindigkeiten nach der Kollision
            self_angle = math.atan2(self.vel_y, self.vel_x)
            other_angle = math.atan2(other_ball.vel_y, other_ball.vel_x)
            self_speed = math.sqrt(self.vel_x ** 2 + self.vel_y ** 2)
            other_speed = math.sqrt(other_ball.vel_x ** 2 + other_ball.vel_y ** 2)
            new_self_angle = self_angle - angle
            new_other_angle = other_angle - angle

            # Vertauschen der Geschwindigkeitskomponenten tangential zur Kollisionsrichtung
            self_vel_x = math.cos(new_self_angle) * self_speed
            self_vel_y = math.sin(new_self_angle) * self_speed
            other_vel_x = math.cos(new_other_angle) * other_speed
            other_vel_y = math.sin(new_other_angle) * other_speed

            # Berechnung der neuen Geschwindigkeiten nach dem elastischen Stoß
            final_self_vel_x = ((self_vel_x * (self.radius - other_ball.radius) + (
                    2 * other_ball.radius * other_vel_x)) / (
                                       self.radius + other_ball.radius)) * math.cos(angle) + self_vel_x * math.cos(
                angle + math.pi / 2) * math.cos(angle)
            final_self_vel_y = ((self_vel_x * (self.radius - other_ball.radius) + (
                    2 * other_ball.radius * other_vel_x)) / (
                                       self.radius + other_ball.radius)) * math.sin(angle) + self_vel_x * math.cos(
                angle + math.pi / 2) * math.sin(angle)
            final_other_vel_x = ((other_vel_x * (other_ball.radius - self.radius) + (
                    2 * self.radius * self_vel_x)) / (
                                         self.radius + other_ball.radius)) * math.cos(angle) + other_vel_x * math.cos(
                angle + math.pi / 2) * math.cos(angle)
            final_other_vel_y = ((other_vel_x * (other_ball.radius - self.radius) + (
                    2 * self.radius * self_vel_x)) / (
                                         self.radius + other_ball.radius)) * math.sin(angle) + other_vel_x * math.cos(
                angle + math.pi / 2) * math.sin(angle)

            # Setzen der neuen Geschwindigkeiten
            self.vel_x = final_self_vel_x
            self.vel_y = final_self_vel_y
            other_ball.vel_x = final_other_vel_x
            other_ball.vel_y = final_other_vel_y
