import pygame
import math

pygame.init()

# Bildschirmabmessungen
WINDOW_WIDTH, WINDOW_HEIGHT = 800, 600
WINDOW_SIZE = (WINDOW_WIDTH, WINDOW_HEIGHT)

# Farben
WHITE = (255, 255, 255)
GREEN = (0, 128, 0)
RED = (255, 0, 0)
BLACK = (0, 0, 0)
YELLOW = (255, 255, 0)

# Initialisierung des Fensters
window = pygame.display.set_mode(WINDOW_SIZE)
pygame.display.set_caption("Billard")

# Klasse für die Kugel
class Ball:
    def __init__(self, x, y, color, radius, vel_x=0, vel_y=0):
        self.x = x
        self.y = y
        self.color = color
        self.radius = radius
        self.vel_x = vel_x
        self.vel_y = vel_y
        self.visible = True
        self.stopped = False

    def draw(self):
        if self.visible:
            pygame.draw.circle(window, self.color, (self.x, self.y), self.radius)

    def move(self):
        if self.visible and not self.stopped:
            self.x += self.vel_x
            self.y += self.vel_y

    def check_wall_collision(self):
        if self.x - self.radius <= 0 or self.x + self.radius >= WINDOW_WIDTH:
            self.vel_x = -self.vel_x
        if self.y - self.radius <= 0 or self.y + self.radius >= WINDOW_HEIGHT:
            self.vel_y = -self.vel_y

    def stop(self):
        self.vel_x = 0
        self.vel_y = 0
        self.stopped = True

# Klasse für den Queue
class Cue:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.length = 10
        self.maxLength = 400
        self.angle = 0
        self.visible = False

    def update(self):
        mouse_x, mouse_y = pygame.mouse.get_pos()
        dx = mouse_x - self.x
        dy = mouse_y - self.y

        self.angle = math.atan2(dy, dx)
        self.length = min(math.sqrt(dx ** 2 + dy ** 2), self.maxLength)

    def draw(self):
        if self.visible:
            end_x = self.x + self.length * math.cos(self.angle)
            end_y = self.y + self.length * math.sin(self.angle)
            pygame.draw.line(window, WHITE, (self.x, self.y), (end_x, end_y), 2)

# Funktion zum Anstoßen der weißen Kugel
def shoot_cue(white_ball, cue):
    cue_vel = cue.length * 0.1
    white_ball.vel_x = cue_vel * math.cos(cue.angle)
    white_ball.vel_y = cue_vel * math.sin(cue.angle)
    cue.visible = False

# Kollisionserkennung zwischen den Kugeln
def check_ball_collision(ball1, ball2):
    dx = ball1.x - ball2.x
    dy = ball1.y - ball2.y
    distance = math.sqrt(dx ** 2 + dy ** 2)

    if distance <= ball1.radius + ball2.radius:
        # Berechnung der neuen Geschwindigkeiten nach der Kollision
        angle = math.atan2(dy, dx)
        mass1 = 1  # Masse der weißen Kugel
        mass2 = 2  # Masse der roten und schwarzen Kugel

        # Geschwindigkeitsvektoren der Kugeln
        v1 = math.sqrt(ball1.vel_x ** 2 + ball1.vel_y ** 2)
        v2 = math.sqrt(ball2.vel_x ** 2 + ball2.vel_y ** 2)
        phi1 = math.atan2(ball1.vel_y, ball1.vel_x)
        phi2 = math.atan2(ball2.vel_y, ball2.vel_x)

        # Berechnung der neuen Geschwindigkeiten nach der Kollision
        ball1.vel_x = ((v1 * math.cos(phi1 - angle) * (mass1 - mass2) + (2 * mass2 * v2 * math.cos(phi2 - angle))) / (
                mass1 + mass2)) * math.cos(angle) + v1 * math.sin(phi1 - angle) * math.cos(angle + math.pi / 2)
        ball1.vel_y = ((v1 * math.cos(phi1 - angle) * (mass1 - mass2) + (2 * mass2 * v2 * math.cos(phi2 - angle))) / (
                mass1 + mass2)) * math.sin(angle) + v1 * math.sin(phi1 - angle) * math.sin(angle + math.pi / 2)
        ball2.vel_x = ((v2 * math.cos(phi2 - angle) * (mass2 - mass1) + (2 * mass1 * v1 * math.cos(phi1 - angle))) / (
                mass1 + mass2)) * math.cos(angle) + v2 * math.sin(phi2 - angle) * math.cos(angle + math.pi / 2)
        ball2.vel_y = ((v2 * math.cos(phi2 - angle) * (mass2 - mass1) + (2 * mass1 * v1 * math.cos(phi1 - angle))) / (
                mass1 + mass2)) * math.sin(angle) + v2 * math.sin(phi2 - angle) * math.sin(angle + math.pi / 2)

# Funktion zur Überprüfung, ob eine Kugel in eine Tasche gelocht wurde
def check_pocket_collision(ball, pockets):
    for pocket in pockets:
        dx = ball.x - pocket.x
        dy = ball.y - pocket.y
        distance = math.sqrt(dx ** 2 + dy ** 2)

        if distance <= pocket.radius:
            return True

    return False

def main():
    clock = pygame.time.Clock()

    # Erstellen der Kugeln
    global white_ball, red_ball, black_ball
    white_ball = Ball(WINDOW_WIDTH // 4, WINDOW_HEIGHT // 2, WHITE, 20)
    red_ball = Ball(WINDOW_WIDTH * 3 // 4, WINDOW_HEIGHT // 3, RED, 20)
    black_ball = Ball(WINDOW_WIDTH * 3 // 4, WINDOW_HEIGHT * 2 // 3, BLACK, 20)

    # Erstellen des Queues
    cue = Cue(white_ball.x, white_ball.y)

    # Taschen (Fangkörbe) erstellen
    pocket1 = Ball(30, 30, BLACK, 30)
    pocket2 = Ball(WINDOW_WIDTH - 30, 30, BLACK, 30)
    pockets = [pocket1, pocket2,
               Ball(30, WINDOW_HEIGHT - 30, BLACK, 30),
               Ball(WINDOW_WIDTH - 30, WINDOW_HEIGHT - 30, BLACK, 30),
               Ball(WINDOW_WIDTH // 2, 30, BLACK, 30),
               Ball(WINDOW_WIDTH // 2, WINDOW_HEIGHT - 30, BLACK, 30)]

    # Reset-Button erstellen
    reset_button_x = (pocket1.x + pocket2.x) // 2 - 260
    reset_button_y = 10
    reset_button_width = 100
    reset_button_height = 30

    cue.visible = True

    balls = [white_ball, red_ball, black_ball]

    playing = True
    while playing:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                playing = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                if cue.visible:
                    shoot_cue(white_ball, cue)

                # Überprüfen, ob der Reset-Button angeklickt wurde
                mouse_pos = pygame.mouse.get_pos()
                if reset_button_x <= mouse_pos[0] <= reset_button_x + reset_button_width and \
                        reset_button_y <= mouse_pos[1] <= reset_button_y + reset_button_height:
                    reset_game()

        # Bewegung der roten und schwarzen Kugeln, wenn nicht gestoßen
        if not cue.visible:
            for ball in balls[1:]:
                ball.move()
                ball.check_wall_collision()

                if abs(ball.vel_x) < 0.1 and abs(ball.vel_y) < 0.1:
                    ball.stop()

        # Bewegung der weißen Kugel
        white_ball.move()
        white_ball.check_wall_collision()

        if abs(white_ball.vel_x) < 0.1 and abs(white_ball.vel_y) < 0.1:
            white_ball.stop()
            cue.visible = True
            cue.x = white_ball.x
            cue.y = white_ball.y

        # Kollisionserkennung zwischen den Kugeln, wenn nicht gestoßen
        if not cue.visible:
            for i in range(len(balls)):
                for j in range(i + 1, len(balls)):
                    check_ball_collision(balls[i], balls[j])

        # Überprüfung, ob Kugeln in Taschen gelocht wurden
        if check_pocket_collision(white_ball, pockets):
            print("Weiße Kugel gelocht!")
            white_ball.stop()
            white_ball.x = WINDOW_WIDTH // 4
            white_ball.y = WINDOW_HEIGHT // 2
            cue.visible = True
            cue.x = white_ball.x
            cue.y = white_ball.y

        if check_pocket_collision(red_ball, pockets):
            print("Rote Kugel gelocht!")
            red_ball.visible = False

        if check_pocket_collision(black_ball, pockets):
            print("Schwarze Kugel gelocht!")
            black_ball.visible = False

        # Hintergrund zeichnen
        window.fill(GREEN)

        # Taschen zeichnen
        for pocket in pockets:
            pocket.draw()

        # Kugeln zeichnen
        for ball in balls:
            ball.draw()

        # Queue zeichnen
        cue.x = white_ball.x
        cue.y = white_ball.y
        cue.update()
        cue.draw()

        # Reset-Button zeichnen
        pygame.draw.rect(window, RED, (reset_button_x, reset_button_y, reset_button_width, reset_button_height))
        font = pygame.font.SysFont(None, 25)
        text = font.render("RESET", True, WHITE)
        window.blit(text, (reset_button_x + 25, reset_button_y + 8))

        pygame.display.update()
        clock.tick(60)

    pygame.quit()

def reset_game():
    global white_ball, red_ball, black_ball

    white_ball.x = WINDOW_WIDTH // 4
    white_ball.y = WINDOW_HEIGHT // 2
    white_ball.vel_x = 0
    white_ball.vel_y = 0
    white_ball.visible = True
    white_ball.stopped = False

    red_ball.x = WINDOW_WIDTH * 3 // 4
    red_ball.y = WINDOW_HEIGHT // 3
    red_ball.vel_x = 0
    red_ball.vel_y = 0
    red_ball.visible = True

    black_ball.x = WINDOW_WIDTH * 3 // 4
    black_ball.y = WINDOW_HEIGHT * 2 // 3
    black_ball.vel_x = 0
    black_ball.vel_y = 0
    black_ball.visible = True

if __name__ == "__main__":
    main()
